# Interactors

Интерактор - это реализация сценария использования(usecase).
Термин пришел из Clean architecture Роберта Мартина.

Сценарии использования описывают взаимодействие пользователя с приложением.
В противоположность предметной модели, зти бизнес-правила применимы только
в контексте компьютерной программы и не могут выполняться вручную.
Например, комиссию при банковском переводе можно расчитать вручную,
поэтому расчет комиссии - это служба предметной области.

В этом слое также могут содержаться сущности и службы.
Например, модель текущего пользователя приложения.
Текущий пользователь - это сущность имеющая значение только в контексте автоматизации.

Также как и слой предметной области, слой сценариев содержит собственные абстракции.
Когда мы описываем сценарий, мы еще не знаем, где будут храниться данные, сессия,
какой язык будет использоваться для запросов. Нам нужно объявить только протокол.

Расмотрим сценарий входа в систему.
Его основной путь состоит из следующих шагов:

+ пользователь передает системе логин и пароль
+ система проверяет, что пользователь еще не вошел в систему
+ система проверяет, что логин и пароль имеют правильный тип и формат
+ система по логину находит пользователя и проверяет пароль
+ система записывает в сессию, что пользователь вошел в систему

Есть и побочные пути. Требуется показывать сообщение об ошибке, когда:

+ пользователь уже залогинен
+ логин и пароль имеют неправильный формат
+ в системе нет пользователя с таким логином или не подходит пароль

```clojure
(defn process [params]
  (let [err (or (check-logged-out)
                (check-params params))]
    (if (some? err)
      err
      (do
        (let [user (find-user params)
              err  (check-authentication user params)]
          (if (some? err)
            err
            (do
              (user-session/log-in! user)
              {:type ::processed :user user})))))))
```

Получается не очень понятно. Дело в том, что в clojure отсутствует ранний возврат из функции.
Но clojure это lisp, и есть возможность расширять синтаксис с помощью макросов.
Существует библиотека [better-cond](https://github.com/Engelberg/better-cond),
которая линеаризует код:

```clojure
(b/defnc process [params]
  :let [err (or (check-logged-out)
                (check-params params))]
  (some? err) err
  :let [user (find-user params)
        err  (check-authentication user params)]
  (some? err) err
  :do (user-session/log-in! user)
  {:type ::processed :user user})
```

Принципиальным моментом тут является то, что по коду метода `process` можно восстановить
исходную формулировку сценария, т.е. это самодокументирующийся код. Такой подход существенно
упрощает поддержку кода. Подробнее можно прочитать в книге
[Совершенный код](https://www.ozon.ru/context/detail/id/138437220/)
или докладе Ментальное программирование
[1.0](https://www.youtube.com/watch?v=EEq1wdM2M2w),
[2.0](https://devconf.ru/ru/offers/offer/328).

Прежде чем переходить к дальнейшему объяснению реализации interactors,
нужно разобраться с абстракциями хранения данных.



// TODO: перенести и переработать

## Сессия

В нашем случае сессия это нечно, что моделирует сессию работы пользователя с системой.
Фактически это key-value хранилище, сохраняющее состояние между разными запросами к системе.

```clojure
(ns publicator.interactors.abstractions.session
  (:refer-clojure :exclude [get set!]))

(defprotocol Session
  (-get [this k])
  (-set! [this k v]))

(declare ^:dynamic *session*)

(defn get [k]
  (-get *session* k))

(defn set! [k v]
  (-set! *session* k v))
```

Вот и протокол, подходящий под эти требования.

Для тестов нам подойдет наивная реализация:

```clojure
(ns publicator.fake.session
  (:require
   [publicator.interactors.abstractions.session :as session]))

(deftype FakeSession [storage]
  session/Session
  (-get [_ k] (get @storage k))
  (-set! [_ k v] (swap! storage assoc k v)))

(defn build []
  (FakeSession. (atom {})))

(defn binding-map []
  {#'session/*session* (build)})
```

Т.е. состояяние хранится внутри атома.
