# Введение {#intro}

В своей работе я сталкивался со различными сложностями.

* Борьба с фреймворком.
  Авторы ферймворков создают их для решения собственных проблем, а не ваших.
  Авторы фреймворка могут изменять его, а вы нет.
  Вы вынуждены продолжать использовать фреймворк, когда он перестал подходить.

* Частые изменения требований.
  Бизнес, который обслуживается вашим приложением постоянно изменяется.
  По другому быть не может. Таков мир.

* Раннее принятие решений.
  Еще не разобравшисть в предметной области проекта мы должны принимать решения.
  Какая база данных? Какая схема таблиц?
  Какой фреймворк?
  Веб приложение? Мобильное приложение?

* Работа в команде
  Затраты на синхронизацию.
  Конфликты в системе контроля версий.

Все это относится к проектам которые длятся от полугода
и разрабатываются по гибким методологиям.

Есть несколько книг, которые поднимают эти вопросы, а так же множество других.

* Архитектура корпоративных программных приложений. Мартин Фаулер.
* Принципы, паттерны и методики гибкой разработки на языке C\#. Роберт Мартин.
* Clean Architecture. Роберт Мартин.
* Проблемно-ориентированное проектирование\(DDD\). Эрик Эванс.

Описанное в этих книгах резко контрастирует с моим опытом.
Редко кто может похвастаться тем,
что его команде доставляет удовольствие работа с проектом даже спустя годы после старта.

У подобных книг есть общая проблема. Они дают теоритическую базу, но не дают практику.
Я покажу как спроектировать и написать приложение с нуля используя идеи из перечисленных книг.

Мы познакомимся с:

* принципами SOLID
* Clean architecture
* паттерном Data Mapper
* паттерном Unit of Work
* паттерном Identity Map

У меня получилось осмыслить и реализовать эти идеи только после экспериментов
с языком Clojure. Первое впечателние можно сформировать на основе:
[rationale](https://clojure.org/about/rationale) и
[Effective Programs, 10 Years of Clojure](https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/EffectivePrograms.md).
Clojure поддерживает динамический полиморфизм, что позволяет использовать многие ООП подходы,
разделяет состояние и идентичность, в противоположность императивным языкам,
что позволяет тривиально отслеживать изменения при разработки слоя сохранения данных.
В процессе изложения с буду давать пояснения и сссылки на материалы,
так что не переживайте, если не знакомы с этим языком и подходами.
