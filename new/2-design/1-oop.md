В этом параграфе я расскажу как clojure соотносится с ООП.

Есть 2 ассоцииации с ООП:

+ Инкапсуляция, наследование и полиморфизм
+ Обмен сообщениями

Clojure - полная противоположность привычным ООП языкам в смысле инкапсуляции.
В clojure функции и данные разделены. При этом поощряется максимальная открытость.
Как правило данные моделируются с помощью Map или записей, а они открыты для чтения
и модификации кем угодно.

А про полиморфизм и немного про наследование поговорим поподробнее.



Главной заслугой ООП языков, вроде C++ или Java, является реализация удобного и безопасного
динамического полиморфизма в сравнении с языком C, где приходилось использовать указатели на функции.

Полиморфизм дает возможность обращать зависимости и проектировать приложение с помощью плагинов.
Например, класс A использует класс B. `A --использует-> B`.
В этом случае зависимость между этими модулями в момент компиляции и в процессе исполнения совпадает.
А теперь реализуем плагин: класс A использует интерфейс IB, а В реализует IB.
`A --испльзует-> IB <-наследует-- B`. Таким образом в момент компиляции A знает только про интерфейс,
а в момент выполнения устанавливается конретная реализация IB - B.
Таким образом, без перекомпиляции пакета с A и IB можно изменять поведение A.
Это позволяет гибко подходить к разработке и откладывать приняние технических решений. В следующем разле
я раскажу подробно про этот подход.
