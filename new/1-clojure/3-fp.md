# Функциональная парадигма

Я буду называть функциональными те языки, в которых отсутствует или ограничено присваивание.

Например, в javascript есть присваивание и переменные:

```javascript
let x = 1
let f = () => x
x = 2
f() // => 2
```

В clojure это не так:

```clojure
(let [x 1
      f (fn [] x)
      x 2]
  (f)) ;; => 1
```

Философия clojure - большая часть программы должна следовать функциональной парадигме.
Для оставшихся частей есть специальный механизм для работы с изменяющимся состоянием.

## Atom

```clojure
(let [x (atom 1)
      f (fn [] @x)
      _ (reset! x 2)]
  (f)) ;; => 2
```

Атом можно рассматривать как контейнер, способный заменять свое значение и контроллирующий доступ из нескольких потоков.
Для замены своего значения атом использует атомарную операцию *Сравнение с обменом (Compare And Swap)*.
Атом имеет следующий интерфейс:

+ `(atom 1)` - новый атом с начальным значением 1
+ `@x` - доступ к значению атома `x`, в один момент времени все потоки прочитают одно и тоже значение
+ `(reset! x 2)` - установка значения атома `x` в 2 не учитывая предыдущее значение
+ `(swap! x inc)` - замена значения с помощью функции `inc`

`swap!` работает следующим образом:

+ Запоминаем текущее состояние атома. Это легко сделать, т.к. данные неизменяемы.
+ Применяем переданную функцию к запомненному значению.
+ Атомарно сравниваем запомненное значение с текущем и если оно не изменилось,
  устанавливаем новое значение. Если занчение изменилось, начинаем сначала.

Под атомарностью тут понимается, что сравнение с обменом - неделимая операция,
т.е. другой поток не сможет заменить значение когда сравнение случилось, а обмен еще нет.

Если запустить 5 параллельных потока(thread), то значение счетчика будет равно 5.
Если бы атом не поддерживал *Compare And Swap (CAS)*, то значение счетика было бы меньше 5,
т.к. параллельные потоки затирали бы результаты друг друга.

```clojure
(let [counter (atom 0)]
  (->> (range 5)
       (map (fn [_] (future (swap! counter inc))))
       (map deref)
       (doall))
  @counter) ;; => 5
```

Макрос `future` выполняет свое содержимое в другом потоке и возвращает future.
Функция `deref` блокирует текущий поток, дожидается исполнения `future` и возвращает результат.
`map` возвращает ленивую коллекцию, поэтому мы используем `doall`, чтобы вычислить все ее элементы.

Кроме атомов в clojure есть и другие контейнеры. С их помощью реализуется Software Transaction Memory.
Позже я дам ссылки на соответствующие материалы, а пока, на текущем этапе, поверхностного знакомства с атомами достаточно.

## Состояние и идентичность

Рассмотрим привычный подход к моделированию.
Допустим, наша программа обрабатывает данные людей,
и нам важно знать имя, возраст, количество друзей и размер сбережений:

```javascript
//javascript
class Person {
  constructor(name, age, friends, savings) {
    this.name = name
    this.age = age
    this.friends = friends
    this.savings = savings
  }
}

let alice = new Person("Alice", 22, 5, 100)
```

С течением времени Алиса менялась.
Каждый день она находится в каком-то определенном состоянии.

Например, сегодня, в ее день рождения, она получила в подарок 300 монет.

```javascript
alice.age++
alice.savings += 300
```

Или, в другой день, она не отдала долг другу и потеряла его:

```javascript
alice.savings += 10
alice.friends -= 1
```

Важно отметить, что она увеличила накопления и потеряла друга одномоментно,
но наша модель не соответствует этому. Модель становится противоречивой в момент, когда
увеличились накопления, но еще не изменилось количество друзей.

Также, наша модель позволяет записать аттрибуты постороннего человека:
```javascript
alice.name = "Bob"
```

При таком подходе происходит объединение понятий *Идентичность* и *Состояние*.
Идентичность это нечто, что однозначно определяет моделируемую сущность.
А состояние - это некие данные, описывающие сущность в заданный момент времени.

В нашем случае, идентичность - это сам объект, т.е. та область памяти, которую он занимает.
Если бы объекты в javascript имели `object_id`, то он и представлял бы идентичность.
Этим же объектом моделируется и состояние сущности.

Также Несколько странно говорить о изменении прошлых состояний девушки.
Ведь она может переходить в новое состояние, но это не должно изменять ее прошлые состояния.

В Clojure эти понятия разделяются.
Состояние моделируется с помощью неизменяемых структур данных,
а идентичность - с помощью ссылочных типов, вроде атомов.

```clojure
(def alice (atom {:name "Alice"
                  :age 22
                  :friends 5
                  :savings 100}))

;; устанавливаем валидатор, запрещающий изменять имя
(set-validator! alice (fn [new-state]
                         (= (:name new-state)
                            (:name @alice))))


;; одномоментно увеличиваем накопления и теряем друга
(swap! alice (fn [state]
                 (-> state
                     (update :savings + 100)
                     (update :friends - 1))))

(swap! alice assoc :name "Bob")
;; Boom!
;; IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)
```


**TODO: дописать**

Про то, что в одну реку нельзя войти дважды?
Картинка?
