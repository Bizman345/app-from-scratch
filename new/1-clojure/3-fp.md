# Функциональная парадигма

Я буду называть функциональными те языки, в которых отсутствует или ограничено присваивание.

Например, в javascript есть присваивание и переменные:

```javascript
let x = 1
let f = () => x
x = 2
f() // => 2
```

В clojure это не так:

```clojure
(let [x 1
      f (fn [] x)
      x 2]
  (f)) ;; => 1
```

Философия clojure - большая часть программы должна следовать функциональной парадигме.
Для оставшихся частей есть специальный механизм для работы с изменяющимся состоянием.

## Atom

```clojure
(let [x (atom 1)
      f (fn [] @x)
      _ (reset! x 2)]
  (f)) ;; => 2
```

Атом можно рассматривать как контейнер, способный заменять свое значение.
Для замены своего значения атом использует атомарную операцию *Сравнение с обменом (Compare And Swap)*.
Атом имеет следующий интерфейс:

+ `(atom 1)` - новый атом с начальным значением 1
+ `@x` - доступ к значению атома `x`
+ `(reset! x 2)` - установка занчения атома `x` в 2
+ `(swap! x inc)` - замена значения с помощью функции `inc`

`swap!` работает следующим образом:

+ Запоминаем текущее состояние атома. Это легко сделать, т.к. данные неизменяемы.
+ Применяем переданную функцию к запомненному значению.
+ Атомарно сравниваем запомненное значение с текущем и если оно не изменилось, устанавливаем новое значение.
  Если занчение изменилось, начинаем сначала.


Если запустить 5 параллельных потока(thread), то значение счетчика будет равно 5.
Если бы атом не поддерживал *Compare And Swap (CAS)*, то значение счетика было бы меньше 5,
т.к. параллельные потоки затирали бы результаты друг друга.

```clojure
(let [counter (atom 0)]
  (->> (range 5)
       (map (fn [_] (future (swap! counter inc))))
       (map deref)
       (doall))
  @counter) ;; => 5
```

Кроме атомов в clojure есть и другие контейнеры. С их помощью реализуется Software Transaction Memory.
Позже я дам ссылки на соответствующие материалы, а пока, на текущем этапе, поверхностного знакомства с атомами достаточно.

## Модель времени

Clojure выделяет следующие понятия:

+ состояние - некое неизменяемое значение
+ идентичность - серия состояний

Состояние моделируется неизменяемыми структурами данных вроде списков, векторов, ассоциативных массивов.
Идентичность моделируется с помощью контейнеров вроде атомов.

При таком подходе в нашей программе появляется понятие времени.


**TODO: дописать**

Про Волгу?
Картинка?
