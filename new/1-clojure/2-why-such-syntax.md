# Зачем такой синтаксис?

Принципиальное отличие LISP от других языков - гомоиконность.
Т.е. код - это данные. Другим гомоиконным языком является ассемблер.

В прочих языках, вроде javascript, код записывается текстом.
В случае LISP, код записывается с помощью структур данных самого языка.
Это наглядно видно при использовании `eval`. `eval` - команда, для интерперетации кода.

```js
const code = "1 + 2"
eval(code) //=> 3
```

```clojure
(let [code (quote (+ 1 2))]
  (eval code)) ;;=> 3
```

`quote` - останавливает выполнение, и преобразует код в данные.

Без `quote` `code` ссылался бы просто на значение 3, т.к. произошло бы выполнение `(+ 1 2)`:

```clojure
(let [code (quote (+ 1 2))]
  (assert (not= 3 code)))
```

Существует краткая форма для записи `quote` - `'`.
Далее я буду использовать именно на этот вариант:

```clojure
(let [code '(+ 1 2)]
  (eval code)) ;;=> 3
```

`'(+ 1 2)` создает спискок из 3х элементов: символа `+` и 2х чисел:

```clojure
(let [code '(+ 1 2)
      operator (first code)
      operand  (second code)]
  (assert (= clojure.lang.PersistentList (class code)))
  (assert (= clojure.lang.Symbol (class operator)))
  (assert (= java.lang.Long (class operand))))
```

Символ - специальный тип данных, подобный keyword, но представляющий некое название.
Символ `x` можно создать следующими способами: `'x`, `(symbol "x")`.
Если рассматривать следующий код как данные, то символами будут: `let`, `x`, `y` и `+`.

```clojure
(let [x 1
      y 2]
  (+ x y))
```

Важно отметить, что `'` экранирует все, что находится внутри скобок.
Если вам не нужно экранирование, но нужно создать список, то следует использовать функцию `list`:

```clojure
(let [x 1
      y 2
      code-1 (list '+ x y)
      code-2 '(+ x y)]
    (assert (not= code-1 code-2))
    (assert (= '(+ 1 2) code-1)))
```

## Макросы

То обстоятельство, что код записан в виде структур данных, дает нам возможность модифицировать код с помощью этого же языка.

Например, мы можем написать функцию, которая дает возможность записывать арифметические выражения привычным способом.

```clojure
;; (1 + 2) => (+ 1 2)
(defn infix-fn [infixed]
  (let [operand-1 (first infixed)
        operator  (second infixed)
        operand-2 (last infixed)]
      (list operator operand-1 operand-2)))

(let [infixed '(1 + 2)
      code    (infix-fn infixed)
      result  (eval code)]
  (assert (= 3 result)))
```

Но практической ценности от такой функции мало. Каждый раз нужно вызывать `eval`.

В LISP есть функции, выполняющиеся на этапе компиляции. Это макросы:

```clojure
;; просто вызываем нашу функцию
;; вместо вызова можно скопировать сюда ее тело
(defmacro infix [infixed]
  (infix-fn infixed))

(assert (= 3 (infix (1 + 2))))

;; macroexpand - это аналог eval для макросов
;; т.е. он разворачивает макрос в runtime
(let [code '(infix (1 + 2))
      compiled (macroexpand code)]
    (assert (= '(+ 1 2) compiled)))
```

Т.е. макрос выполняется на этапе компиляции и принимает в качестве аргументов куски кода как данные.
Макрос возвращает структуру данных, которая затем будет исполнена при запуске программы.

## Разделение ответственности

При таком подходе четко выделяются 2 ответственности:

+ то, что код делает
+ то, как код выглядит

Например, нам нужно сделать инкремент для каждого элемента, взять нечетные элементы и посчитать сумму элементов.
Выглядит это усташающе:

```clojure
(reduce + (filter odd? (map inc [0 1 2 3])))
```

Можно заметить, что все эти функции принимают коллекцию последним аргументом.
Для такого случая есть макрос `->>`:

```clojure
(->> [0 1 2 3]
     (map inc)
     (filter odd?)
     (reduce +))

(macroexpand '(->> [0 1 2 3]
                   (map inc)
                   (filter odd?)
                   (reduce +)))
;;=> (reduce + (filter odd? (map inc [0 1 2 3])))
```

Этот макрос берет свой первый аргумент,
подставляет его на последнее место в свой второй аргумент,
результат вычисления, подставляет в третий, и так далее.

Важно понять, что этот макрос работает с любыми функциями.
Например, в javascript нет макросов и для соединения функций в цепочки
каждая библиотека реализует свой способ:

```javascript
// https://lodash.com/docs/4.17.5#chain

var users = [
  { 'user': 'barney',  'age': 36 },
  { 'user': 'fred',    'age': 40 },
  { 'user': 'pebbles', 'age': 1 }
];

var youngest = _
  .chain(users)
  .sortBy('age')
  .map(function(o) {
    return o.user + ' is ' + o.age;
  })
  .head()
  .value();
```

## Заключение

LISP языки называют программируемыми яыками программирования.
Вы можете самостоятельно расширять язык новыми синтаксическими конструкциями.
При этом ядро языка остается маленьким и простым.
