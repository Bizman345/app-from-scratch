Цель - просто показать язык, намеренно опуская многие детали.

```clojure
;; После запуска нужно немного поджождать,
;; пока repl.it поднимет окружение для запуска скрипта.
;; Справа можно будет вводить свои команды.


;; Используется только префиксная(польская нотация),
;; т.е. оператор стоит всегда на первом месте.

;; печать на экран
(prn "hello world")

;; Для демонстации языка воспользуемя утверждениями(assert).
;; Если агрумент ложный, то будет брошено исключение,
;; если истинный, то просто вернется nil.
(assert true) ;; #=> nil
;; (assert false) ;; AssertionError Assert failed: false
;; (assert nil)   ;; AssertionError Assert failed: nil

;; привычные операторы могут принимать переменное количество аргуметов
(assert (= 1)) ;;
(assert (= 1 1 1)) ;; 1 = 1 = 1

(assert (< 1))
(assert (< 1 2 3)) ;; 1 < 2 < 3

;; примитивные типы - java типы
(assert (= java.lang.String  (class "some string")))
(assert (= java.lang.Long    (class 1)))
(assert (= java.lang.Boolean (class true)))

;; значение можно связать с названием
;; новое значение можно связвть с тем  же  названием
(let [x 1
      x 2]
  (assert (= 2 x)))

;; это именно связывание, а не присваивание
(let [x 1
      f (fn [] x) ;; анонимная функция замыкает x = 1
      x 2]
  (assert (= 2 x))
  (assert (= 1 (f))))

;; Имена могут содержать некоторые спецсимволы.
(let [x 1
      x' x
      x? x
      ?x x
      x! x
      !x x
      +x+ x
      -x- x
      *x* x
      =x= x]
  (assert (= x x' x? ?x x! !x +x+ -x- *x* =x=)))

;; vector
(let [x [0 "str" true [1 2 3]]]
  (assert (= "str" (get x 1)))
  (assert (= 0 (first x)))
  (assert (= "str" (second x))))

;; map
;; запятая - просто пробельный символ и используется для улучшения читаемости кода
(let [x {:key 1, "key" 2, 2 3, true "4", [1 2] "5", nil 6}]
  (assert (= 1 (get x :key)))
  (assert (= 6 (get x nil))))

;; keyword
;; Представляют сами себя. Аналог символов в ruby или атомов в erlang.
;; Используются как ключи в ассоциативных массивах.
;; Реализуют интефейс функций.
(let [x {:key "value"}]
  (assert (= "value" (:key x))))

;; Все clojure значения - неизменяемые.
;; При изменении возвращается новый объект, старый остается доступен.
;; При этом не происходит полного копирования,
;; т.е. новая структура переиспользует старую.
(let [x  [0 1 2 3]
      x' (pop x)]
  (assert (= [0 1 2 3] x))
  (assert (= [0 1 2] x')))

(let [x {}
      x' (assoc x :k1 1 :k2 2)]
  (assert (= {} x))
  (assert (= {:k1 1, :k2 2} x')))

;; распаковка
(let [x [0 1 2]
      [a & other] x]
  (assert (= 0 a))
  (assert (= [1 2] other)))

(let [x {:a 1, :b 2}
      {:keys [a]} x]
  (assert (= 1 a)))

;; функции как значения
;; `+` - функция
(assert (= 6 (reduce + [0 1 2 3])))

;; замыкания
;; fn - начало объявления анонимной функции
(let [x 1
      f (fn [y] (+ x y))]
  (assert (= 3 (f 2))))

;; краткая запись функции одного аргумента
(let [x [0 1 2]
      x'  (map #(+ 2 %) x)
      x'' (map (fn [i] (+ 2 i)) x)]
  (assert (= x' x'')))

;; объявление функции в текущем пространстве имен
(defn own-inc [x]
  (+ 1 x))

(assert (= 1 (own-inc 0)))
```


Этот код можно выполнить в прямо в браузере.
https://repl.it/@darkleaf/clojure-tour
Там же можно поиграться и проверить разные гипотезы.


Здесь чуть больше примеров:
https://learnxinyminutes.com/docs/clojure/
**ОБЯЗАТЕЛЬНО** к просмотру.



repl.it, clojurescript.io, может еще есть какой-нибудь онлайн репл

Подробнее - будет дальше.


Пока ничего ставить и изучать по clojure не нужно. На этом этапе важно поверхностное знакомство.
Далее будут ссылки на подробные материалы.
