# Абстракции сценария использования

При рассмотрении предметной области мы уже сталикивались с принципом инверсии зависимости.
Для того, что бы перейти к сцанариям использования нужно сначала разобраться с абстракциями,
определенными на этом уровне.

Напомню, что реализация сценариев использования содержатся в модулях уровнем ниже,
чем предметная область. Следовательно все что объявлено в модулях сценариев использования
зав


## Хранилище

Хранилище - это нечто, что сохраняет состояние сущностей.
Я очень долго думал и искал различные варианты того, как работать с хранилищем.


Модель предметной области находится в модулях самого высокого уровня.
Сущности не могут зависеть от

то сущности не должны зависеть
Сущности не должны зависеть от абстракции


Существуют

Для работы с сущностями нужна абстракция со следующими свойствами:

+ извлечение сущности по ее идентификатору
+ повторное извлечение сущности по идентификатору
  возвращает тот же объект что и предыдущее извлечение
  (Identity map)
+ сущности ничего не знают про хранилище,
  мы работаем с сущностаями как с простыми структурами данных
  (Datamapper)
+ поддержка ACID транзакций


Есть несколько требований


Хранилище нужно для сохраниения состояния сущностей.
Это может быть mysql, postgres, mongodb, elasticsearch, redis, файл, оперативная память.




## Сессия

В нашем случае сессия это нечно, что моделирует сессию работы пользователя с системой.
Фактически это key-value хранилище, сохраняющее состояние между разными запросами к системе.

```clojure
(ns publicator.interactors.abstractions.session
  (:refer-clojure :exclude [get set!]))

(defprotocol Session
  (-get [this k])
  (-set! [this k v]))

(declare ^:dynamic *session*)

(defn get [k]
  (-get *session* k))

(defn set! [k v]
  (-set! *session* k v))
```

Вот и протокол, подходящий под эти требования.

Для тестов нам подойдет наивная реализация:

```clojure
(ns publicator.fake.session
  (:require
   [publicator.interactors.abstractions.session :as session]))

(deftype FakeSession [storage]
  session/Session
  (-get [_ k] (get @storage k))
  (-set! [_ k v] (swap! storage assoc k v)))

(defn build []
  (FakeSession. (atom {})))

(defn binding-map []
  {#'session/*session* (build)})
```

Т.е. состояяние хранится внутри атома.
